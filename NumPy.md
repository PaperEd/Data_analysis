# Numpy
- 파이썬 라이브러리를 이용한 데이터 분석 책을 읽고 정리한 내용입니다.
- `import numpy as np`
## ndarray
- 메모리를 빠르고 효율적이게 사용가능
- 산술 연산과 브로드캐스팅 기능 제공
### 생성 방법
#### **np.array()**  
- 기존 배열에서 데이터를 받아와 `ndarray`로 만들어준다. 
```
data = [1,2,3,4,5] 
arr = np.array(data1) 
```
#### **np.zeros()**  
- 0으로 초기화한 `ndarray` 생성  
```
np.zeros(10)  
-> array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((2,2))  
-> ([0., 0.],  
[0., 0.])`  
```
#### **np.ones()**  
- 1으로 초기화 한 `ndarray` 생성
- `np.zeros()` 와 사용 방법이 같다.
#### **np.empty()**
  - 초기화되지 않은 `ndarray`를 반환하는 함수
  - `np.zeros()` 와 사용 방법이 같다.
#### **np.eye()**
- N * N 크기의 행렬 생성
- 좌상단에서 우하단을 잇는 대각선은 1로 채워진다.
```
array = np.eye(3)
print(array)
-> [[1, 0, 0],
    [0, 1, 0],
    [0, 0, 1]]
```
#### np.zeros_like( ), ones_like( ), empty_like( )
- 인자로 들어가는 배열과 같은 크기의 배열을 생성한다.
```
arr = np.ones(5)
arr2 = np.zeros_like(arr)
print(arr2)
-> [0, 0, 0, 0, 0]
```
#### np.full( )
- 첫번째 값은 배열의 크기, 두번째 값은 배열에 들어갈 값인 배열을 생성한다.
```
arr = np.full((2, 2), 3)
print(arr)
->[[3, 3],
   [3, 3]]
``` 
#### np.arange( )
- 특정한 규칙에 따라 증가하는 수열을 만든다.
- 기존 파이썬의 `range`라고 볼 수 있다
```
print(np.arange(5)) # 0 .. n - 1
-> [0, 1, 2, 3, 4]
print(np.arange(3, 15, 3)) # 시작, 끝(포함 X), 증가 수
-> [3, 6, 9, 12]
```
#### np.random.rand( ), np.random.randn( )
- `rand`는 uniform 분포를 따르는 난수를 생성한다.
- `randn`은 가우시안 정규 분포를 따르는 난수를 생성한다.
- `random.seed`를 사용해 시드값을 지정할 수 있다.
#### np.linespace( 시작, 끝, 개수 )
- 정해진 구간을 지정한 수만큼 분할한다.
---  
### 자료형
- `np.arange(10, dtype=)`와 같이 괄호 안에 `dtype=`을 넣어줌으로서 자료형을 지정할 수 있다.
#### int8 (i1), int16 (i2), int32 (i3), int64 (i4) 
- 부호가 있는 n비트 정수형과 부호가 없는 n비트 정수형이다.
#### float16 (f2)
- 반정밀도 부동소수점이다.
#### float32 (f4 or f)
- 단정밀도 부동소수점이다.
- C언어의 `float`형과 호환된다.
#### float64 (f8 or d)
- 배정밀도 부동소수점이다.
- C언어의 `double`형과 호환된다.
- 파이썬의 `float` 객체와 호환된다.
#### float128 (f16 or g)
- 확장 정밀도 부동소수점이다.
#### complex64,128,256 (c8, c16, c32)
- 각각 2개의 32,64,128비트의 부동소수점형을 가지는 복소수다.
#### bool (?)
- True, False 값을 저장하는 불리언형이다.
#### object (0)
- 파이썬 객체형
#### string_ (S)
- 고정 길이 문자열형 (각 글자는 1바이트)
- 길이가 n인 문자열의 dtype는 Sn
#### unicode_ (U)
- 고정 길이 유니코드형 (플랫폼에 글자별 바이트 수가 다르다)
- `string_` 과 같은 형식을 사용 (Ex: U10)
#### astype
- `ndarray`의 `astype` 메소드를 사용해 배열의 `dtype`을 다른 형으로 명시적 변경 가능하다.
```
     arr = np.array([1, 2, 3, 4, 5])
      arr.dtype
      -> dtype('int64')
      
      float_arr = arr.astype(np.float64)
      float_arr.dtype
      -> dtype('float64')
```
  - 부동소숫점 숫자를 정수형을 변환하면 소수점 아래자리는 버려진다.
```
      arr = np.array([1.2, 3.4])
      arr
      -> array([1.2, 3.7])

      arr.astype(np.int32)
      -> array([1, 3] dtype=int32)
```
- `astype`을 호출하면 `dtype`이 이전 `dtype`과 같아도 항상 새로운 배열을 생성함.
---
### 배열과 스칼라 간의 연산
- 스칼라 값에 대한 연산은 각 요소로 전달된다.
```
arr = np.array([1, 2, 3])
arr
-> ([1, 2, 3])
arr * arr
-> ([2, 4, 6])
arr / arr
-> ([1, 1, 1])
arr + 3
-> ([4, 5, 6]) 
```
---
  
### 색인과 슬라이싱 기초
- 1차원 배열은 파이썬의 리스트와 유사하게 동작된다.
#### 스칼라를 대입하면 값이 선택 영역 전체에 전파된다.
```
arr = np.arange(6)
arr
-> ([0, 1, 2, 3, 4, 5])
arr[5]
-> 5
arr[1:4]
-> ([1, 2, 3])
arr[1:4] = 9
arr
-> [(0, 9, 9, 9, 4, 5)]
```
#### 기본적으로 ndarray는 배열을 복사하면 같은 포인터를 지정하게 된다.
```
arr = np.arange(5)
print(arr)
-> [0, 1, 2, 3, 4]
arr_slice = arr[2:4]
print(arr_slice)
-> [2, 3]
arr_slice[:] = 10
print(arr)
-> [0, 1, 10, 10, 4]
```
- `ndarray` 슬라이스의 복사본을 얻고싶으면 `arr[2:4].copy()`과 같은 방식을 이용해서 복사해야 한다.
#### 다차원 배열일 경우, 각 색인에 해당하는 요소는 각 1차원 배열이 된다.
```
arr2d = np.arange(9).reshape((3,3))
arr2d[2]
-> ([6, 7, 8])  
```
#### 개별 요소는 콤마로 구분된 색인으로 지목할 수 있다.
```
arr2d[0][2]
-> 3
arr2d[0, 2]
-> 3
```
#### 팬시 색인
  - 정수 배열을 사용한 색인을 설명하기 위한 단어이다.
#### 배열 전치와 축 바꾸기
  - `.T`를 사용한다.
```
arr = np.arange(6).reshape((2, 3))
arr.T
-> ([[0, 3],
[1, 4],
[2, 5]])
```
---
### 유니버셜 함수
- `ufunc`라고 불리는 함수이다.
- `ndarray`안에 있는 데이터를 원서별로 수행하는 함수이다.
- 하나 이상의 스칼라 값을 받아서 반환한다.

### 단항 유니버셜 함수
- 인자를 하나만 받는 유니버셜 함수이다.
#### **abs( )**, **fabs( )**
- 정수, 실수, 복소수의 절대값을 구한다.
- 복소수가 아닌 경우에는 속도가 빠른 `fabs`를 사용한다.
#### **sqrt( )**
- 각 원소의 제곱근을 계산한다.
- `arr ** 0.5`와 동일하다.
#### **square( )**
- 각 원소의 제곱을 계산한다.
- `arr ** 2`와 동일하다.
#### **exp( )**
- 각 원소에서 지수를 계산한다.
#### **Log( ), log10(), log2( ), log1p( )**
- 각각 자연 로그, 로그 10, 로그 2, 로그(1 + x)
#### **sign( )**
- 각 원소의 부호를 계산한다.
- 양수: 1, 0: 0, 음수: -1
#### **ceil( )**
- 각 원소의 소수자리를 올린다.
#### **floor( )**
- 각 원소의 소수자리를 내린다.
#### **rint**
- 각 원소를 반올림한다.
#### **modf( )**
- 각 원소의 몫과 나머지를 각각의 배열로 반환한다.
#### **isnan( )**
- 각각의 원소가 숫자인지 아닌지 나타내는 `Boolean` 배열을 반환한다.
#### **isfinite( ), isinf( )**
- 각 원소가 유한한지, 무한한지 나타내는 `Boolean` 배열을 반환한다.
#### **cos, cosh, sin, sinh, tan, tanh**
- 일반 삼각 함수와 쌍곡삼각 함수
#### **arccos, arccosh, arcsin, arcsinh, arctan, arctanh**
- 역삼각 함수
#### **logical_not( )**
  - 각 원소의 not값을 계산한다. `-arr`과 동일하다.

---

### 이항 유니버셜 함수
- 인자를 2개 받는 유니버셜 함수이다.
#### **add( )**
- 두 배열에서 같은 위치의 원소끼리 더한다.
#### **subtract( )**
- 첫번째 배열에서 두번째 배열의 원소를 뺀다.
#### **multiply( )**
- 배열의 원소끼리 곱한다.
#### **divide( ), floor_divide( )**
- 첫번째 배열의 원소에서 두번째 배열의 원소를 나눈다.
- `floor_divide()`는 몫만 가져온다.
#### **power( )**
- 첫 번째 배열의 원소에 두번째 배열의 원소만큼 제곱한다.
#### **maximum( ), fmax( )**
- 각 배열의 원소중 큰 값을 반환한다.
- `fmax( )` 는 `NaN`을 무시한다.
#### **minimum( ), fmin( )**
- 각 배열의 원소 중 작은 값을 반환한다.
- `fmin( )`은 `NaN`을 무시한다.
#### **mod( )**
- 첫번째 배열의 원소에서 두번째 배열의 원소를 나눈 나머지를 구한다.
#### **copysign( )**
- 첫번째 배열의 원소의 기호를 두번째 배열의 원소의 기호로 바꾼다.
#### **greater, greater_equal, less, less_equal, equal, not_equal**
- 각각 >, >=, <, <=, ==, != 비교연산의 결과를 `Boolean` 배열로 반환한다.
#### **logical_and, logical_or, logical_xor**
- 각각 두 원소간의 논리연산:  & , | , ^ 에 대한 결과를 반환한다.
---
### 배열을 사용한 데이터 처리
- NumPy 배열을 사용하면 반복문 없이 배열연산이 가능하다
- 배열연산을 사용해 반복문을 명시적으로 제거하는 기법 -> **벡터화**
- 벡터화한 산술연산은 빠르다!
#### meshgrid( )