## 데이터 처리
- 반복문을 사용하지 않는다!
### 배열과 스칼라 간의 연산
- 스칼라 값에 대한 연산은 각 요소로 전달된다.
```
arr = np.array([1, 2, 3])
arr
-> ([1, 2, 3])
arr * arr
-> ([2, 4, 6])
arr / arr
-> ([1, 1, 1])
arr + 3
-> ([4, 5, 6]) 
```
  
## 색인과 슬라이싱 기초
- 1차원 배열은 파이썬의 리스트와 유사하게 동작된다.
### 스칼라를 대입하면 값이 선택 영역 전체에 전파된다.
```
arr = np.arange(6)
arr
-> ([0, 1, 2, 3, 4, 5])
arr[5]
-> 5
arr[1:4]
-> ([1, 2, 3])
arr[1:4] = 9
arr
-> [(0, 9, 9, 9, 4, 5)]
```
### 기본적으로 ndarray는 배열을 복사하면 같은 포인터를 지정하게 된다.
```
arr = np.arange(5)
print(arr)
-> [0, 1, 2, 3, 4]
arr_slice = arr[2:4]
print(arr_slice)
-> [2, 3]
arr_slice[:] = 10
print(arr)
-> [0, 1, 10, 10, 4]
```
- `ndarray` 슬라이스의 복사본을 얻고싶으면 `arr[2:4].copy()`과 같은 방식을 이용해서 복사해야 한다.
### 다차원 배열일 경우, 각 색인에 해당하는 요소는 각 1차원 배열이 된다.
```
arr2d = np.arange(9).reshape((3,3))
arr2d[2]
-> ([6, 7, 8])  
```
### 개별 요소는 콤마로 구분된 색인으로 지목할 수 있다.
```
arr2d[0][2]
-> 3
arr2d[0, 2]
-> 3
```
### 팬시 색인
  - 정수 배열을 사용한 색인을 설명하기 위한 단어이다.
### 배열 전치와 축 바꾸기
  - `.T`를 사용한다.
```
arr = np.arange(6).reshape((2, 3))
arr.T
-> ([[0, 3],
[1, 4],
[2, 5]])
```

### numpy.where( )
- `x if 조건 else y`같은 삼항식을 벡터화 한 버전이다.
- 두번째 인자와 세번째 인자는 배열이 아니여도 된다.
- 값이 `True`면 두번째 인자를, `False`면 세번째 인자를 반환한다.
```
arr1 = np.zeros(5)
arr2 = np.ones(5)
arr3 = np.array([True, False, True, False, True])

res = np.where(arr3, arr1, arr2)
print(res)
-> [ 0., 1., 0., 1., 0.]
```

## 불리언 배열
### sum( )
- `(arr > 0).sum( )`같은 명령을 실행하면 True인 원소의 개수를 반환한다
### any( ), all( )
- `any( )`는 `True`가 하나라도 있으면 `True`를 반환한다
- `all( )`은 모든 원소가 `True`일 때 `True`를 반환한다

### 정렬
- `sort( )`를 사용하자
- 다차원 배열 같은 경우는 `arr.sort(1)`같이 넘긴 축의 값에 따라 1차원 부분을 정렬한다
- `sort( )` 함수는 배열을 직접 변경하는게 아니라 복사본을 반환한다
- 이렇게 하는게 더 빠르기 때문이다